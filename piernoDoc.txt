==============================
Title: Logic Error in isValidInet4Address method

Class: Logic Error

Date: 3/6/16
Reported By: Andrew Pierno
Email: piernoa@oregonstate.edu


Product:    URL Validator
Platform:   OSx                  Version: 10.11.1
Browser:    NA


Is it reproducible: Yes

Description
===========
 When http://256.256.256.256:100/test/ is run through the url validator, it is incorrectly
 passed as a valid url. This is incorrect because the inet4 address should not be above
 255.


Steps to Produce/Reproduce
--------------------------
String url = "http://256.256.256.256";
UrlValidator validator =  new UrlValidator();
boolean test = validator.isValid(url);

Expected Results
----------------
test == false // true


Actual Results
--------------
test == true // true


Workarounds
-----------
If you look in the isValidInet4Address method, there is an if statement
if (iIpSegment > 255) {

  return true;

}
This should return false, and when switched, the urls no longer pass.


Attachments
-----------
none


Other Information
-----------------
How the bug was found and Agan's principles: understanding the system under test was the first step in locating the fault.
Knowing that valid ipv4 addresses should be at or below 255 was a large help in locating where the failure may be.
Making it fail and fail repeatedly was also relatively simple since the programming based tests consistently reported
this bug after repeated runs. Looking into the code, the first file that was suspicious was the inet address validator. Since
there were roughly 100 lines in that file it was simple to locate where the error was happening. I did a quick search for the number
255 and found the error on line 96.



TestIsValid Description:

The test is valid method creates a way to programmatically test url pieces.  It begins by creating an array of options
for the scheme, authority, ports, path, options, and queries consisting of only valid elements. There is then a loop that randomly selects
an item in the array from each of the url pieces and runs them through the url validator. We know that since
each of the url pieces arrays all contain only valid elements, they all should pass. This same procedure is
repeated for url pieces that should fail. Since we know what should and should not pass, it is fairly easy to check
when a test fails. The number of tests can be varied by adjusting the loop counter. The bugs are then kept track of in
another array such that when the tests are complete, we can print out the failed tests and count the number of test results.





Methodology for finding failures.

The first step we took as a group was to write correct test. This may not sound very profound but I came across this several times
when reporting bugs for other students' dominion code when the actual bug was in my test. It helped that the url validator testing
just used a url so there wasn't as much set up required and the complexity of set up was relatively small. This was tremendously helpful
because we could be reasonably sure that a url should pass and that at least the test was a correctly written test. After writing
tests that had a decent amount of coverage based on reading the entire source code base to better understand the system, it was time to
make it fail. Running the programming based tests several thousand times resulted in many failed urls or urls that should have failed but
did not. Making it fail was the simplest part of the process. Next, it was clear there was some similarities between failing tests and the
way a valid url is constructed lent itself well to divide and conquer. We could effectively trim off parts of the url to see what the smallest
url string could be while still making the test fail ( or pass incorrectly ). It should be noted, smallest here simply means a url with the least
amount of components ( for example, taking the port number and query off of a url. ). At the same time we were dividing and conquering, we were
also only changing one url component at a time, and re-running the tests to make sure the outcome didnt unexpectedly change. Once the url could not
be trimmed any further, there was typically only a few places ( functions ) to look for the fault. After identifying the method the error was in
it was fairly trivial to change one suspicious thing at a time to find the failure line. Sometimes it was helpful to comment out the whole
function and return a static value ( perhaps making the test pass if it was failing ) to know that you are in the correct method that has the
failure.
