First just do manual testing. Call the valid method of URLValidator with different possible valid/invalid
inputs and see if you find a failure. (2 points)





Second, come up with good input partitioning. Try to provide a varying set of inputs that partition the
overall input set well. Did you find any failures? You can call valid method once or more for each partition. (3 points)

-- Input Partitioning Complete




Third, do programming based testing. Write few unit test cases. You can have some sort of loop in your
unit test and test different url with each instance of loop. Something very similar to testIsValid() but
your own logic and idea. Even a single test will be sufficient if you write it like testIsValid() method.
Did you find any failures? Submit your test files and test cases as part of your
work under your onid/URLValidator folder.   (5 points)

-- Programming based testing Complete

The test is valid method creates a way to programmatically test url pieces.  It begins by creating an array of options
for the scheme, authority, ports, path, options, and queries consisting of only valid elements. There is then a loop that randomly selects
an item in the array from each of the url pieces and runs them through the url validator. We know that since
each of the url pieces arrays all contain only valid elements, they all should pass. This same procedure is
repeated for url pieces that should fail. Since we know what should and should not pass, it is fairly easy to check
when a test fails. The number of tests can be varied by adjusting the loop counter. The bugs are then kept track of in
another array such that when the tests are complete, we can print out the failed tests and count the number of test results.




When you find out any failure, debug using Eclipse debugger and try to localize its cause.
Provide at what line/lines in what file the failure manifested itself. Did you use any of Aganâ€™s
principle in debugging URLValidator?  (5 points)

Methodology for finding failures.

The first step we took as a group was to write correct test. This may not sound very profound but I came across this several times
when reporting bugs for other students' dominion code when the actual bug was in my test. It helped that the url validator testing
just used a url so there wasn't as much set up required and the complexity of set up was relatively small. This was tremendously helpful
because we could be reasonably sure that a url should pass and that at least the test was a correctly written test. After writing
tests that had a decent amount of coverage based on reading the entire source code base to better understand the system, it was time to
make it fail. Running the programming based tests several thousand times resulted in many failed urls or urls that should have failed but
did not. Making it fail was the simplest part of the process. Next, it was clear there was some similarities between failing tests and the
way a valid url is constructed lent itself well to divide and conquer. We could effectively trim off parts of the url to see what the smallest
url string could be while still making the test fail ( or pass incorrectly ). It should be noted, smallest here simply means a url with the least
amount of components ( for example, taking the port number and query off of a url. ). At the same time we were dividing and conquering, we were
also only changing one url component at a time, and re-running the tests to make sure the outcome didnt unexpectedly change. Once the url could not
be trimmed any further, there was typically only a few places ( functions ) to look for the fault. After identifying the method the error was in
it was fairly trivial to change one suspicious thing at a time to find the failure line. Sometimes it was helpful to comment out the whole
function and return a static value ( perhaps making the test pass if it was failing ) to know that you are in the correct method that has the
failure.



Provide a report called URLValidator.pdf/URLValidator.txt (5 points). You need to provide following
details in the report:





Clearly mention your methodology of testing.
For manual testing, provide some of your (not all) urls.
"http:/en.wikipediA.org"	"http//en.wikipediA.org""http:///en.wikipediA.org""http://www.en.wikipediA.org""http://wwwwwwww.en.wikipediA.org""http://w.en.wikipediA.org""http://org.en.wikipediA.www""http://en.wikipediA.org""http://rrr.en.wikipediA.org""http://kkk.en.wikipediA.org""http://WWW.en.wikipediA.org""http://en.wikipedi>A.org""http://en.wikipediA.oRg""http://en.wiki?pediA.org""http://en.wiki[p]ediA.org""http://en.wik'i'pediA.org""http://en.w>ikipediA.org""http://en.wikipediA0.org""http://www.1234.com"));	
"http://en.wikipediA.org"));	"htps://www.oregonstate.edu"));	"tttt://www.oregonstate.edu"));	

For partitioning, mention your partitions with reasons.

testDomainPartitions, domain partition test function
The testDomainPartitions method steps through an array of input domains, calling the isValid method on each potential url
combination. What make this method helpful for testing is each url is passes to the isValid method consists of valid
url piece combinations except for a single element. For example a possible url it will pass to isValid is "http//www.google.com/test/testing?t=1"
what makes this url example helpful is only the url scheme portion of the url is invalid. This lets implements Agan's
5th testing principle "Only change 1 thing at a time" automatically across multiple tests, helping us localize bugs.

Partions
We made 4 different partitions based on how the isValid method checks a url. We divided up each partition into two
separate partitions; one with valid and another with invalid values. This allowed us to toggle one partition at a time
as invalid, helping us to localize faults.

Scheme partitions
Reading through the documentation for valid/invalid schemes it seemed three different things could result in
and scheme being declared as invalid; scheme misspelling, incorrect colon's and brackets, and last not including a scheme.
To support this we divided this partition into 3; first we made the scheme invalid by misspelling http.
Next we removed the color from http which should should also cause the url to fail. Last we didn't include the
scheme at all.

Authority partitions
Reading through documentation of authority we found how its determined as valid invalid was very similar to
the scheme. It validates IP, urls without www, and urls with www so we broke this partition into 3.
The first invalid value selected was blank, as they are never used. The next was an IP address to large (it had
a 265 in it) and last was an invalid IP address with not enough numbers. Curiously this input partition revealed a bug
in the isValid method with its "valid" partitions. The "www.google.ru" wasn't being passed as valid. A bug report was
written noting this.

Path partitions
For our path partitions we determined blank paths (paths only with a space character) and paths not beginning
with a "/" are considered invalid. So we divided this partition in 2. The first invalid value is " " and the second
is begins with a letter instead of a "/".

Query partitions
The Query partition was dividing into two. The first invalid test case had invalid
characters which should a cause a failure as noted in the url query standards. The second
was designed to test a query in an invalid format (not following the ?field=value)
format defined in the query specifications, the test cased didn't include the "?" mark
which indicates the string is a query.



For unit tests/random tests, submit your unit tests using svn under URLValidator folder.





In report files mention the name of your tests.





Also mention, how did you work in the team? How did you divide your work? How did you
collaborate?

How We Worked Together

We communicated through email and Google Hangouts. To collaborate during test development we relied
heavily on our groups Github repo we set up specifically for this project. At each stage
of the project, we held a meeting on Google Hangouts and divided the work. For part A, we all contributed to
the text document. For part B, we each took a different testing method, researched, then developed the method
and pushed our tests and with a writeup to the shared repo. Then we all had another group meeting where each of
us introduced our test method and walked the rest of the group through the test method. This line-by-line
code review helped ensure our test methods were functioning the way we intended. Once we accepted the test methods
we began debugging. Each of us were assigned a bug we didn't actually locate, that way we had to work through
parts of the code we weren't as familiar with to localize the fault. This helped us better apply Agan's principles
and write non-biased bug reports.




Write bug report for each of the bugs you found. Bug report should follow all the standard bug
reporting principle, Use apache commons validator issue tracking system issues as standard to write bug report.






Please mention in the bug report, file name and line number where bug manifested itself. Provide your
 debugging details for each bugs. You don't need to report bugs using svn, just dump your bug report in the
 URLValidator.pdf/.txt file.


 BUG REPORT:
 ==============================
 Title: Logic Error in isValidInet4Address method

 Class: Logic Error

 Date: 3/6/16
 Reported By: Andrew Pierno
 Email: piernoa@oregonstate.edu


 Product:    URL Validator
 Platform:   OSx                  Version: 10.11.1
 Browser:    NA


 Is it reproducible: Yes

 Description
 ===========
  When http://256.256.256.256:100/test/ is run through the url validator, it is incorrectly
  passed as a valid url. This is incorrect because the inet4 address should not be above
  255.


 Steps to Produce/Reproduce
 --------------------------
 String url = "http://256.256.256.256";
 UrlValidator validator =  new UrlValidator();
 boolean test = validator.isValid(url);

 Expected Results
 ----------------
 test == false // true


 Actual Results
 --------------
 test == true // true


 Workarounds
 -----------
 If you look in the isValidInet4Address method, there is an if statement
 if (iIpSegment > 255) {

   return true;

 }
 This should return false, and when switched, the urls no longer pass.


 Attachments
 -----------
 none


 Other Information
 -----------------
 How the bug was found and Agan's principles: understanding the system under test was the first step in locating the fault.
 Knowing that valid ipv4 addresses should be at or below 255 was a large help in locating where the failure may be.
 Making it fail and fail repeatedly was also relatively simple since the programming based tests consistently reported
 this bug after repeated runs. Looking into the code, the first file that was suspicious was the inet address validator. Since
 there were roughly 100 lines in that file it was simple to locate where the error was happening. I did a quick search for the number
 255 and found the error on line 96.
