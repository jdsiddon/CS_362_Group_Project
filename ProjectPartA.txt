Group Members: Onur Ozay, Andrew Pierno, Justin Siddon, Martin Stryffeler

Explain testIsValid Function of UrlValidator test code.

The testIsValid method that is called in main() accepts no parameters. This method calls another 
testIsValid() method that accepts two parameters, an array of url parts, and a long value.

This method grabs a piece of a potential url (5 parts, scheme, authority, port, path, query) from each's 
respective arrays and creates a url to test.

Since each piece of a url is stored with a valid/invalid flag one invalid flag should make the entire url 
invalid. This method loops over each url 'part' and checks if the flag is set to valid/invalid. One invalid 
will set the expected result to invalid, this is done on the last line of the for loop 
"expected &= part[index].valid;".

It then compares this valid/invalid value with the value that is actually returned by the isValid method of the 
UrlValidator class. If these match then the test passes. If they don't match, then the flags attached to each 
url part is incorrect or there is a bug with the isValid method.


Give how many total number of urls it is testing. Also, explain how it is building all the urls.

The total number of urls being tested is 1,890. The urls are generated by combining 5 different url parts 
( again the 5 parts are the scheme, authority, port, path, query ). Each part of the url has its own ResultPair, 
which says if that part of the url is valid or invalid. The url is complete when it has chosen an item from each 
of the 5 parts, and is then ready to be tested.


Give an example of valid url being tested and an invalid url being tested by testIsValid() method.

An example of a valid url is 'http://www.google.com' and an example of an invalid url is '://.1.2.3.4:-1/../..'. 
The invalid test here has each of the 5 parts constructed from 'failing' parts but the test will fail if any one 
of the 5 parts of the url are invalid.


Do you think that a real world test (URL Validator's testIsValid() test in this case) is very different than the 
unit tests and card tests that we wrote (in terms of concepts & complexity)?

The real world tests are not very different than the unit tests and card tests we wrote for the dominion code base. 
They both operate under the same principles such as identifying exactly what we want to test and knowing when the 
test should pass or fail. They are also similar in their labeling of passing and failing tests. For the dominion 
code, we could either use assertions or print out failing test cases without assertions but either way, we were 
labeling our test cases just like in testIsValid(). Another similarity is in the preconditions for generating a 
good test. The testIsValid method must generate a url to test and in the dominion code, we had to make sure to 
create a valid game state to test against.
